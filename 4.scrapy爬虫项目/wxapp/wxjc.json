{"title": "微信小程序开发之页面分享 onShareAppMessage 分享参数用处 ", "author": "Rolan", "pub_time": "2019-8-19 00:08", "content": "今天下午突然听到群里有人说微信小程序工具更新了,文档也更新了不少内容.顾不上吃冬至的饺子.我就冲进来了.先说分享功能,目前真机尚不能调试.开发工具上可以看看效果.后续还会更新.Page()中加上如下代码后在右上角就会出现三个小白点title:分享的标题.desc:分享一段描述.path:这个参数有点意思.以前在微信中的分享一般都是url.这里是当前页面这里应该是pages/index?id=123这里的id目前还不知道是什么.也就是说以后你可以在微信中像分享一个网页一样分享一个页面了.onShareAppMessage: function () {\r\n    return {\r\n      title: '垃圾分类黑板报',\r\n      desc: '垃圾分类就选垃圾分类黑板报!',\r\n      path: '/page/user?id=123'\r\n    }\r\n  }分享参数用处:我这里没有用到路径后的参数,说个场景:参数是用户昵称,A分享了XXX小程序到微信群里,B点开小程序,弹个toast,”来自A的分享”."}
{"title": "uni-app开发一个小视频应用(二) ", "author": "Rolan", "pub_time": "2019-10-9 00:32", "content": "一、前情回顾uni-app开发一个小视频应用(一)上篇文章，我们已经实现了首页的头部导航栏组件、底部的tabBar导航栏组件、中间的视频列表组件以及视频列表组件中的视频播放组件，传入视频列表渲染后已经可以上下滑动进行视频切换和播放，接下来我们将完成首页的剩余部分，左侧信息栏组件、右侧图标栏组件，以及完善视频切换动画、播放控制等功能。二、创建左侧信息栏组件左侧的信息栏组件，主要分三块: 作者名、视频标题名、音乐名。这个左侧信息栏信息是和当前播放视频相关联的，所以应该在循环视频列表的时候，将左侧信息栏组件一起渲染出来，所以左侧信息栏组件应该加到<swiper-item>中。// components/list-left.vue<template>\r\n    <view class=\"list-left\">\r\n        <view class=\"author\">\r\n            @祝晓晗\r\n        </view>\r\n        <view class=\"title\">\r\n            妈呀，遇到老同学了，缘分呐! @老丈人说车 @抖音小助手\r\n        </view>\r\n        <view class=\"music-box\"> <!--该music-box主要是为了在music内容滚动的时候在超出music-box范围后能够隐藏超出部分-->\r\n            <view class=\"music\">\r\n                @祝晓晗创作的原声 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  @祝晓晗创作的原声\r\n            </view>\r\n        </view>\r\n    </view>\r\n</template>\r\n<style scoped>\r\n    .list-left{\r\n        width: 70%;\r\n        height: 120px;\r\n        color: white;\r\n    }\r\n    .author {\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 17px;\r\n    }\r\n    .title {\r\n        width: 100%;\r\n        line-height: 25px;\r\n        font-size: 12px;\r\n        word-wrap: break-word;\r\n        color: #FFFAF0;\r\n    }\r\n    .music-box {\r\n        overflow: hidden; <!--滚动的时候超出部分隐藏-->\r\n        width: 70%;\r\n    }\r\n    .music {\r\n        width: 200%;\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 12px;\r\n        animation: scroll-x 5s linear 0.2s infinite; <!--应用动画-->\r\n    }\r\n    @keyframes scroll-x{ <!--添加文字水平滚动动画-->\r\n        0% {\r\n            transform: translate3d(80%, 0, 0); <!--80%位置出现，然后向左边滚动-->\r\n        }\r\n        100% {\r\n            transform: translate3d(-80%, 0, 0); <!--动画结束后到达-80%位置-->\r\n        }\r\n    }\r\n</style>\r\n// components/video-list.vue<template>\r\n    <view class=\"video-list\">\r\n        <view class=\"swiper-box\">\r\n            <swiper class=\"swiper\" :vertical=\"true\">\r\n                <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n                    <view class=\"swiper-item\">\r\n                        <video-player                         \r\n                             :video=\"item\"                        \r\n                            :index=\"index\">\r\n                        </video-player>\r\n                    </view>\r\n                    <view class=\"left-box\"> <!--将左侧信息栏组件放到<swiper-item>中同视频一起渲染出来-->\r\n                        <list-left></list-left>\r\n                    </view>\r\n                </swiper-item>\r\n            </swiper>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style>\r\n.left-box { <!--给左侧列表组件添加绝对定位 并设置z-index以显示到视频上方-->\r\n        position: absolute;\r\n        bottom: 50px;\r\n        left: 10px;\r\n        z-index: 20; \r\n}\r\n</style>三、创建右侧图标栏组件右侧图标栏组件，主要分为: 头像图标(头像设置border-radius)、收藏图标(iconfont图标)、评论图标(iconfont图标)、分享图标(iconfont图标)、音乐图标(图片设置border-radius)，右侧图标栏组件设置一个固定宽度，然后让各种图标依次排列即可，如:// components/list-right.vue<template>\r\n    <view class=\"list-right\">\r\n        <view class=\"author-img\">\r\n            <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-xin\"></view>\r\n            <view class=\"count\">72.2w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-pinglun1\"></view>\r\n            <view class=\"count\">1.8w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-arrow-\"></view>\r\n            <view class=\"count\">6645</view>\r\n        </view>\r\n        <view class=\"music-img\">\r\n            <img class=\"img\" src=\"../static/music.jpg\"/>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style scoped>\r\n    .list-right {\r\n        width: 60px;\r\n    }\r\n    .author-img {\r\n        width: 60px;\r\n        text-align: center;\r\n    }\r\n    .img {\r\n        width: 50px;\r\n        height: 50px;\r\n        border-radius: 50%;\r\n    }\r\n    .author-img img{\r\n        border: 2px solid #FFFFFF;\r\n    }\r\n    .right-box {\r\n        margin: 20px auto;\r\n        color: white;\r\n        text-align: center;\r\n        font-size: 12px;\r\n    }\r\n    .icon {\r\n        font-size: 40px;\r\n    }\r\n    .music-img {\r\n        width: 60px;\r\n        height: 51px;\r\n        text-align: center;\r\n        margin-top: 20px;\r\n        animation: around 1.5s linear 0.2s infinite; <!--使用动画-->\r\n    }\r\n    @keyframes around { <!--添加360环绕旋转动画-->\r\n        0% {\r\n            transform: rotate(0deg);\r\n        }\r\n        100% {\r\n            transform: rotate(360deg);\r\n        }\r\n    }\r\n</style>四、给右侧图标组件添加上相应的事件当点击头像下部的加号图标，可以对该用户进行关注，即隐藏加号图标，还有就是收藏爱心图标颜色切换，当点击收藏爱心图标，爱心图标变成红色，再次点击收藏爱心图标，爱心图标变回白色，这里先只处理颜色的变化，具体后台交互暂不处理。// 在头像图标下方通过绝对定位添加一个加号图标，并定位到头像底部<view class=\"author-img\">\r\n    <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n    <view class=\"follow iconfont icon-jiahao\" v-show=\"showFollow\" @click=\"hideFollow\"><!--添加一个加号图标，以及监听hideFollow事件-->\r\n    </view>\r\n</view>\r\n\r\n<view class=\"right-box\">\r\n    <view class=\"icon iconfont icon-xin\" :class=\"{fav: isFav}\" @click=\"changeColor\"></view><!--监听切换收藏爱心图标颜色-->\r\n    <view class=\"count\">72.2w</view>\r\n</view>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                showFollow: true,\r\n                isFav: false\r\n            }\r\n        },\r\n        methods: {\r\n            hideFollow() { // 隐藏关注加号图标\r\n                this.showFollow = false;\r\n            },\r\n            changeColor() {\r\n                this.isFav = !this.isFav; // 切换收藏爱心颜色\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style scoped>\r\n.follow {\r\n        color: white;\r\n        position: absolute;\r\n        width: 18px;\r\n        height: 18px;\r\n        line-height: 18px;\r\n        background: red;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        left: 23px;\r\n        bottom: -5px;\r\n        font-weight: bold;\r\n}\r\n.fav {\r\n        color:red;\r\n}\r\n</style>五、实现滑动播放功能所谓滑动播放，即向上滑动的时候，暂停当前播放视频并且播放下一个视频，向下滑动的时候，暂停当前播放视频，播放上一个视频，而这最关键的就是如何判断是向上滑动还是向下滑动。<swiper>组件给我们提供了一个change事件，我们可以监听这个change事件，拿到滑动完成后滑动到了第几页，即<swiper-item>的序号(从0开始)，然后与滑动前的当前page相比较，就可以知道是向上滑还是向下滑了。判断好了是上滑还是下滑后，我们还需要对上滑和下滑作出正确的处理，我们需要能够拿到每个视频播放组件，然后调用视频播放组件上的相关方法对播放进行控制，这就是涉及到了父组件如何调用子组件上方法，父组件要想调用子组件上的方法，关键是父组件要能够拿到子组件对象，我们可以通过ref实现，因为每一个视频播放组件是video-list视频列表组件的一个子组件，所以我们可以在video-list视频列表组件中给每一个video-player视频播放组件添加上一个ref=\"player\"，即可拿到对应的视频播放组件了。// components/video-list.vue<swiper class=\"swiper\" :vertical=\"true\" @change=\"slider\"> <!--监听change事件-->\r\n    <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n        <view class=\"swiper-item\">\r\n            <video-player\r\n                ref=\"players\" <!--给每一个视频播放组件添加一个ref标识-->\r\n                :video=\"item\"                        \r\n                :index=\"index\">\r\n            </video-player>\r\n        </view>\r\n    </swiper>\r\n</swiper>\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n            currentPage: 0 // 保存当前page的编号\r\n        }\r\n    },\r\n    methods: {\r\n        slider(e) {\r\n            const targetPage = e.detail.current;\r\n            if (targetPage === this.currentPage + 1) {\r\n                console.log(\"向上滑动\");\r\n                this.$refs.players[this.currentPage + 1].playFromHead(); // 下一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            } else if(targetPage === this.currentPage - 1) {\r\n                console.log(\"向下滑动\");\r\n                this.$refs.players[this.currentPage - 1].playFromHead(); // 上一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            }\r\n                this.currentPage = targetPage;\r\n        }\r\n    }\r\n}\r\n</script>需要注意的是，this.$refs.players返回的是一个数组，即所有播放组件的实例，我们通过不同的索引即可取得对应的视频播放组件，然后进行相应的播放控制了，接下来就是要给每一个视频播放组件添加上播放控制的方法，我们需要给<video>组件添加上一个id，然后通过这个id可以创建出video上下文，即可调用play()、pause()、seek()等相关方法对播放进行控制。// components/video-player.vue<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\" <!--给video组件添加一个id，以便获取到video上下文对象-->\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\">\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\nexport default {\r\n    onReady() {\r\n            this.videoContext = uni.createVideoContext(\"myVideo\", this); // 获取video上下文对象\r\n    },\r\n    methods: {\r\n        play() {\r\n            this.videoContext.play();\r\n        },\r\n        pause() {\r\n            this.videoContext.pause();\r\n        },\r\n        playFromHead() { // 跳转到开始位置并播放\r\n            this.videoContext.seek(0);\r\n            this.play();\r\n        }\r\n    }\r\n}\r\n</script>六、实现单击播放暂停切换以及双击关注用户功能要想实现单击视频播放组件，视频可以进行播放和暂停切换，那么我们需要给视频播放组件添加一个isPlay属性表示视频是否处于播放中，如果是播放中，那么点击就暂停，如果不是播放中，那么点击就播放，同时，由于uni-app不支持vue的dblclick事件的，所以我们还需要对单击和双击操作进行判断，我们需要定义一个变量用于记录用户点击次数，如果300ms内用户点击次数大于等于2，那么就是双击，否则就是单击，如:<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\"\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\"\r\n               @click=\"doClick\"><!--添加click事件进行视频播放和暂停的切换-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    let timer = null; // 定义一个定时器\r\n    export default {\r\n        data() {\r\n            return {\r\n                isPlay: false, // 当前视频是否在播放中，默认为false\r\n                clickCount: 0 // 记录当前用户点击次数，默认为0\r\n            }\r\n        },\r\n        methods: {\r\n            play() {\r\n                this.videoContext.play();\r\n                this.isPlay = true; // 进入视频播放状态设置isPlay为true\r\n            },\r\n            pause() {\r\n                this.videoContext.pause();\r\n                this.isPlay = false; // 进入视频暂停状态设置isPlay为false\r\n            },\r\n            playFromHead() {\r\n                this.videoContext.seek(0);\r\n                this.play();\r\n            },\r\n            doClick() { // 进行视频播放和暂停的切换\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                }\r\n                this.clickCount++; // 每次单击视频播放组件，点击次数加1\r\n                timer = setTimeout(() => {\r\n                    if (this.clickCount >=2 ) { // 如果300ms内点击次数大于等于2就表示是双击了\r\n                        console.log(\"双击\");\r\n                        this.$emit(\"follow\"); // 双击的话向video-list父组件(视频列表组件)发送一个follow事件\r\n                    } else {\r\n                        console.log(\"单击\");\r\n                        if (this.isPlay) {\r\n                            this.pause();\r\n                        } else {\r\n                            this.play();\r\n                        }\r\n                    }\r\n                    this.clickCount = 0; // 重置点击次数为0\r\n                }, 300);\r\n            }\r\n        }\r\n    }\r\n</script>双击的时候会向video-list父组件(视频列表组件)发送一个follow事件，video-list组件监听到follow事件后再通知<list-right>组件调用其方法让其爱心图标变红即可，如:<template>\r\n    <video-player\r\n        @follow=\"follow\">\r\n    </video-player>\r\n    <view class=\"right-box\">\r\n        <list-right ref=\"listRight\"></list-right> <!--给list-right组件添加ref标识-->\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        follow() {\r\n            this.$refs.listRight[0].follow();\r\n        }\r\n    }\r\n</script>七、实现首个视频自动播放功能之前我们的视频播放组件接收了一个index属性，即当前视频对应的索引号，我们可以通过这个索引号判断当前视频是否是第一个，然后将其video组件的autoPlay设置为true即可自动播放。<template>\r\n    <view class=\"video-player\">\r\n        <vide :autoplay=\"auto> <!--绑定autoplay属性控制是否自动播放-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                auto: false // 是否自动播放\r\n            }\r\n        },\r\n        methods: {\r\n            autoPlay() {\r\n                if (this.index === 0) {\r\n                    this.auto = true;\r\n                }\r\n            }\r\n        },\r\n        created() {\r\n            this.autoPlay();\r\n        }\r\n    }\r\n</script>至此，首页已经完成，效果图如下:"}
{"title": "使用 async await 封装微信小程序HTTP请求 ", "author": "Rolan", "pub_time": "2019-10-9 00:55", "content": "1. 编写将普通回调函数形式的方法转换为promise方法的promisic方法 1 // util.js\r\n 2 const promisic = function (func) {\r\n 3     return function (params = {}) {\r\n 4         return new Promise((resolve, reject) => {\r\n 5             const args = Object.assign(params, {\r\n 6                 success: (res) => {\r\n 7                     resolve(res)\r\n 8                 },\r\n 9                 fail: (error) => {\r\n10                     reject(error)\r\n11                 }\r\n12             })\r\n13             func(args)\r\n14         })\r\n15     }\r\n16 }\r\n17 \r\n18 export {\r\n19     promisic\r\n20 } 2. 编写Http类封装HTTP请求 1 // http.js\r\n 2 import { promisic } from \"./util\"\r\n 3 import { config } from \"../config/config\"\r\n 4 \r\n 5 /**\r\n 6  * 使用 async await 封装HTTP请求\r\n 7  */\r\n 8 class Http {\r\n 9 \r\n10     static async request({ url, method='GET', data }) {\r\n11         // 将wx.request方法转换成promise方法\r\n12         const res = await promisic(wx.request)({\r\n13             url: `${config.apiBaseUrl}${url}`,\r\n14             method,\r\n15             data,\r\n16             header: {\r\n17                 appkey: config.appkey\r\n18             }\r\n19         })\r\n20         return res.data\r\n21     }\r\n22 \r\n23 }\r\n24 \r\n25 export {\r\n26     Http\r\n27 } 3. 编写Theme业务类调用封装好的Http请求// theme.js\r\nimport { Http } from \"../utils/http\"\r\n\r\n/**\r\n * 编写主题请求业务类\r\n */\r\nclass Theme {\r\n\r\n    /**\r\n     * 获取首页主题A\r\n     */\r\n    static async getHomeLocationA() {\r\n        return await Http.request({\r\n            url: 'xx/xx/xxx',\r\n            data: {\r\n                names: 't-1'\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport {\r\n    Theme\r\n} 4. 在page中调用Theme业务类获取首页主题A方法 1 // home.js\r\n 2 import { Theme } from '../../model/theme'\r\n 3 \r\n 4 Page({\r\n 5 \r\n 6   data: {\r\n 7     topTheme: {}\r\n 8   },\r\n 9 \r\n10   async onLoad (options) {\r\n11     // 获取首页主题A\r\n12     const data = await Theme.getHomeLocationA()\r\n13     this.setData({\r\n14         topTheme: data[0]\r\n15     })\r\n16   }\r\n17 \r\n18 }) 附上目录结构  这样就可以愉快地使用async await形式的Http请求了，彻底摆脱各种callback方法！"}
{"title": "网易云歌单重合率2.0 ", "author": "Rolan", "pub_time": "2019-10-11 00:31", "content": "前言 \r\n之前写过一个小工具输入网易云音乐上的昵称，即可查看两人喜欢的音乐中，有哪些是相同的，重合率有多少。\r\n感兴趣的可以看这里：\r\n网易云歌单重合率1.0\r\n但是之前的版本存在几个问题：\r\n\r\n速度慢，这个其实是最难受的，平均 20 s以上，因为当时水平有限，使用的selenium相当于模拟了人工搜索，找用户，找歌单，筛选歌曲的过程，会获取很多不必要的信息。速度自然比接口慢很多很多。\r\n体验差，样式也很丑，作为一个小工具，一个链接想再用的时候基本找不到了。\r\n服务经常性不可用。\r\n\r\n但是在我 github 搜网易云的时候发现了一个大佬用 Node.js 写的项目 https://github.com/Binaryify/NeteaseCloudMusicApi  提供了一系列网易云相关的接口，这就很巧了，朋友们，我缺的就是接口啊。（ps:感兴趣的读者可以去 github 上围观这个项目，我只是用了很少的几个接口做成了该工具，事实上，你甚至可以利用其做一个个人风格版的网易云音乐。）\r\n其次前段时间正好买了两本微信小程序的书，而小程序的应用场景之一就是小工具，用完即走。加起来可以完美解决上面三个问题。于是就有了这次的网易云歌单重合率2.0。当然我这个小程序只是练手用，我也没想到如此简陋竟然能通过审核。\r\n使用 \r\n感兴趣可以先直接用微信扫描下方的小程序码体验。\r\n\r\n它用起来大概是这样：\r\n\r\n思路 \r\n代码其实很简单，就不贴了，只说思路。\r\n其实与1.0很相似了，只是以前用PhantomJS和selenium改成用接口获取。\r\n\r\n通过搜索接口传入昵称获取到用户id，\r\n用用户id，拿到喜欢的歌单id，\r\n上传歌单id，获取到歌单详情，即所有的歌曲id。\r\n歌曲id进行比对，重合的歌曲id上传到歌曲详情接口，获取到所有重合歌曲的名字歌手所属专辑等等。\r\n\r\n遇到的问题 \r\n\r\nhttp 转 https \r\n微信的后台只支持 https ,而一般默认https都是用 443 接口，然后 80 端口转到 443 端口，实现 http 转 https 。但是这个项目在服务器用另外一个端口，比如是 5000 ，那么我就必须要申请另外一个端口给这个 5000 用SSL。很麻烦，最简单的方法就是另外用一个二级域名，比如之前是 api.xxx.com 则 这个服务就用node.xxx.com ,然后给 node.xxx.com 申请SSL证书。然后添加反向代理，把 node.xxx.com 转到api.xxx.com:3000 。这样就实现了访问 https://node.xxx.com ,但是实际调用到 http://api.xxx.com:3000 服务。可能有些绕口。\r\n需要注意的是现在免费的话基本只能申请单域名，比如 api.xxx.com ，不能免费申请 *.xxx.com 这种泛域名的证书。至于申请证书后的操作，可自行百度，很多教程，我服务器是腾讯的，通过腾讯云申请后，在宝塔面板添加到SSL>其他证书里的，比较简单快捷。\r\n小程序文本透明度渐显动画\r\n把动画赋值给anim数组元素，然后view绑定这个元素动画。目前是这么实现的，可能存在不合理的地方，欢迎探讨。\r\n//detail.js//获取应用实例const app = getApp()Page({ data: {   anim:[{}], },textShow:function(index){   var animation = wx.createAnimation({     duration: 2000,   });   var key = 'anim[' + index + ']';   animation.opacity(1).step({})   this.setData({     [key] : animation.export(),   }) }, //使用的时候 page.textShow(0); page.textShow(1);})<!--pages/detail/detail.wxml--><view animation=\"{{anim[0]}}\" style=\"opacity:0\" class=\"textViewTitle\">你的昵称:</view><view animation=\"{{anim[1]}}\" style=\"opacity:0\" class=\"textViewTitle\">对方昵称:</view>复制代码\r\n转发功能\r\n一开始上线后，惊人的发现不让转发，一番搜索后才发现，转发分享需要自己实现，并且可以带参。\r\n我实现的效果是在主界面转发只会转发该小程序，不会携带昵称。在结果界面转发会携带昵称，对方点击后直接看结果。\r\n只要重写onShareAppMessage方法即可，path可以携带参数，代码大致如下：\r\n//首页jsonShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: 'pages/index/index',     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } } //结果js onShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: '/pages/detail/detail?myUserName=' + this.data.myUserName + '&otherName=' + this.data.otherName,     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } }复制代码\r\n\r\n总结 \r\n总的来说，小程序开发是非常容易上手的，如果有什么想法的话，不一定非要在Android ,IOS上做一个成品app的，我觉得完全可以借鉴现有的平台试水，比如小程序就是一个不错的平台，开发上手很快，审核也很快。完全可以先用小程序看看方案和思路是否可行，之后再决定是否要做成品app。"}
{"title": "uni-app相关知识总结 ", "author": "Rolan", "pub_time": "2019-10-12 00:43", "content": "一、默认导航栏uni-app默认会提供一个导航栏，即 小程序的导航栏 ，我们不需要进行任何的配置就会显示， 默认导航栏的配置同微信小程序 ，只不过微信小程序的组件是分为.wxml、.wxss、.js、.json四个文件组成，而 uni-app的组件则只有一个.vue文件 (其中包含了html、css、js)，其中并未包含.json的相关内容，那么.json配置写在哪里呢？.json文件主要是 对页面的 窗口表现及页面相关功能进行配置，所以unip在pages.json文件中注册页面的时候，给每个page页面提供了一个style属性，用于对当前页面的窗口表现( 窗口 样式、 导航栏 样式)及功能( 页面下拉刷新 、 页面能否滚动等)，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\": \"pages/index/index\",\r\n            \"style\": { // 对窗口及其页面表现进行配置\r\n                \"navigationBarTitleText\": \"导航标题\", // 设置默认导航栏标题文字内容\r\n                \"navigationBarTextStyle\": \"white\", // 设置默认导航栏标题文字颜色及状态栏上文字颜色，仅支持black和white\r\n                \"navigationBarBackgroundColor\": \"#4CD964\", // 设置默认导航栏背景颜色及状态栏背景颜色，仅支持十六进制颜色值\r\n                \"navigationStyle\": \"default\", // 支持defaul和custom两种，设置custom(自定义)后，默认导航栏将消失，微信小程序上只保持右上角胶囊按钮\r\n                \"backgroundColor\":\"#ADFF2F\", // 设置窗口背景颜色，开启下拉刷新之后，下拉后可见该背景颜色(黄色)，仅小程序端生效\r\n                \"enablePullDownRefresh\": true, // 是否开启页面下拉刷新功能\r\n                // 上拉刷新不需要开启，页面提供了一个触底事件onReachBottom，只要页面存在滚动条，滚动条触底后就可以触发触底事件，从而进行下拉刷新\r\n                \"onReachBottomDistance\": 0, // 当滚动条距离底部的距离为指定值的时候则判定为触底\r\n                \"disableScroll\": false, // 页面能否滚动，如果为true则禁用页面滚动功能，及时页面设置的高度超过了屏幕高度也不会发生滚动，仅小程序端生效\r\n                \"usingComponents\": { // 配置是否使用小程序提供的自定义组件，这里的小程序组件不是.vue组件，而是小程序提供的原生组件，App端也支持\r\n                    \"custom\": \"/wxcomponents/custom/index\"\r\n                },\r\n                // \"backgroundTextStyle\":\"dark\", // 设置下拉 loading 的样式，仅支持dark和light,无明显用处\r\n            }\r\n        }\r\n    ]\r\n}需要注意的就是usingComponents的配置，其配置的是使用 小程序提供的原生组件(如包含.wxml、.wxss、.js、.json的组件) ，而不是.vue组件。同时 状态栏上文字颜色仅支持black和white，即非黑即白，状态栏背景色同导航栏背景颜色二、原生导航栏uni-app运行在app端的时候，还提供了原生导航栏，其在注册页面的时候，style还提供了一个 app-plus 属性用于 配置app端 页面窗口、导航栏样式的配置，导航栏的配置通过titleNView属性，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\": \"pages/index/index\",\r\n            \"style\": { // 对窗口及其页面表现进行配置\r\n                \"app-plus\": {\r\n                    // \"titleNView\": false // 禁用原生导航栏，即当前页面不显示原生导航栏\r\n                    \"scrollIndicator\":\"none\", // 设置是否显示页面滚动条，设置为none，滚动时看不到右侧的滚动条\r\n                    \"pullToRefresh\": {\r\n                        \"style\":\"default\" // 设置下拉刷新样式，只支持default和circle\r\n                    },\r\n                    \"bounce\":\"none\", // 设置页面回弹效果，none关闭回弹效果\r\n                    // \"titleNView\": { // 空对象不会对默认导航栏进行替换，必须进行相关配置才会对默认导航栏进行修改\r\n                        \r\n                    // },\r\n                    \"titleNView\": { // 对原生导航栏进行配置\r\n                        \"titleText\": \"原生导航栏标题内容\", // 标题内容与搜索框只能显示一个\r\n                        \"buttons\": [ // 在原生导航栏上添加按钮\r\n                            {\r\n                                // \"type\":\"share\", // 使用 type 值设置按钮的样式时，会忽略 fontSrc 和 text 属性。\r\n                                \"fontSrc\":\"./static/font/icon.ttf\", // 使用字体图标\r\n                                \"text\": \"\\ue609\", // 使用字体图标时 unicode 字符表示必须 '\\u' 开头\r\n                                \"fontSize\":\"22px\",\r\n                                \"color\":\"#FF9619\", \r\n                                \"colorPressed\":\"#BBBBBB\",\r\n                                \"select\": false, // 是否显示右侧向下箭头图标常用于城市选择\r\n                                \"float\":\"left\" // 按钮放在导航栏左侧\r\n                            },\r\n                            {\r\n                                // \"type\":\"favorite\", // 使用 type 值设置按钮的样式时，会忽略 fontSrc 和 text 属性。\r\n                                \"fontSrc\":\"./static/font/icon.ttf\",\r\n                                \"text\": \"\\ue653\", // 使用字体图标时 unicode 字符表示必须 '\\u' 开头\r\n                                \"fontSize\":\"22px\",\r\n                                \"color\":\"#000000\",\r\n                                \"colorPressed\":\"#BBBBBB\",\r\n                                \"select\": false, // 是否显示右侧向下箭头图标常用于城市选择\r\n                                \"float\":\"right\" // 按钮放在导航栏右侧\r\n                            }\r\n                        ],\r\n                        \"searchInput\": { // 是否在原生导航栏上添加搜索框，一旦添加搜索框，那么导航栏标题内容将无法显示，因为搜索框是放在标题的位置，对标题进行了替换\r\n                            \"align\":\"center\",\r\n                            \"backgroundColor\":\"#F7F7F7\",\r\n                            \"borderRadius\":\"4px\",\r\n                            \"placeholder\":\"搜索\",\r\n                            \"disabled\": true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    ]\r\n}三、自定义导航栏要想自定义导航栏，我们必须先让默认导航栏或者原生导航栏隐藏，在小程序端可以通过 \"navigationStyle\":\"custom\" 隐藏，app端则可以通过 \"titleNView\": false 进行隐藏，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\" : \"pages/contact/contact\",\r\n            \"style\" : {\r\n                \"navigationStyle\":\"custom\", // 隐藏小程序端导航栏\r\n                \"app-plus\": {\r\n                    \"titleNView\": false // 隐藏app端原生导航栏\r\n                }\r\n            }\r\n        }\r\n     ]\r\n}使用自定义导航栏导航后，由于默认导航栏和原生导航栏都消失了，所以原先导航栏的位置就被空出来了，我们可以 通过自定义一个导航视图组件占据原先导航栏的位置即可实现 ，但是下拉刷新会有问题，因为页面的下拉刷新是从顶部开始的，之前 有默认导航和原生导航的时候 ， 页面的顶部就是导航栏底部 ，但是默认导航和原生导航隐藏后， 顶部就变成了原先导航栏的顶部了 ，所以 页面下拉刷新的位置向上移了 ，使用自定义导航栏后最好不要在页面中使用下拉刷新功能了。如果非要使用下拉刷新功能的话，我们可以通过<scroll-view>组件来模拟下拉刷新。即 监听<scroll-view>组件的@scrolltoupper事件判断是否到达顶部，然后监听@scroll事件，判断下拉的位置，然后动态改变下拉刷新的样式、动画 从而模拟出下拉刷新效果。<view class=\"pull-down iconfont icon-liulan\" :style=\"{transform: 'rotate(' + detal+ 'deg)'}\"></view>\r\n<scroll-view scroll-y class=\"scroll-box\" @scrolltoupper=\"pullDown\" @scroll=\"scroll\">\r\n</scroll-view>\r\nexport default {\r\n    methods: {\r\n        pullDown(e) {\r\n            // console.log(e);\r\n        },\r\n        scroll(e) { // 根据下拉的距离改变detal的值从而改变下拉刷新图标的选择角度\r\n            this.detal = e.detail.scrollTop + 100;\r\n        }\r\n    }\r\n}四、vue与nvuenvue即 native vue 。uni-app App端内置 weex 渲染引擎，提供了原生渲染能力。 uni-app默认是处于uni-app的渲染模式 ，即小程序渲染模式，如果要启用纯原生渲染模式，即weex渲染模式，那么需要在 manifest.json 源码视图的 \"app-plus\" 下配置 \"renderer\":\"native\" ，开启原生渲染模式后， pages.json注册的vue页面将被忽略 ，启动纯原生渲染，可以减少App端的包体积、加快App启动速度。因为webview渲染模式的相关模块将被移除了。// manifest.json    \r\n{    \r\n    // ...    \r\n     /* App平台特有配置 */    \r\n    \"app-plus\": {    \r\n        \"renderer\": \"native\", //App端纯原生渲染模式\r\n    }    \r\n}在未开启weex原生渲染模式的情况下，即uni-app模式下也是可以直接渲染.nvue文件的， 不管是vue页面还是nvue页面，都需要在pages.json中注册 ，并且如果一个页面下出现了两个同名的vue和nvue文件，那么在 App端 ， 会优先使用nvue页面 ，同名的vue文件将不会被编译到App端。而在 非App端 ， 会优先使用vue页面 。.nve文件的写法同.vue文件一样，只不过，.nvue文件中可以还使用一些weex提供的特有组件，比如<barcode>、<list>、<cell>、<refresh>等。五、subNvuesubNvue ，是 vue 页面的原生子窗体，其会 把weex渲染的原生界面当做 vue 页面的子窗体覆盖在页面上 ，主要解决 运行在App端时 ， 视图无法覆盖在<video>、<map>等组件上 的问题( 非App端可以通过z-index或者cover-view解决 )，subNvue的使用方式非常简单，只需要 新建一个.nvue文件 ，建议放在母页面目录中，但是 subNvue页面不需要注册到pages.json中 ，而是 在母页的\"style\"--> \"app-plus\" --> \"subNVues\"进行配置 ，因为subNvue主要解决App端层级覆盖问题，所以需要在\"app-plus\"下配置，需要注意的是 subNVues是一个数组 ，每个元素为一个原生子窗体，因为一个母页中可以包含多个原生子窗体，每个原生子窗体通过配置中的id进行区分。配置好subNvues后，对应的原生子窗体默认就会显示。{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/video/video\", // 母页面路径\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"app-plus\": {\r\n                \"titleNView\":false,\r\n                \"subNVues\":[{  \r\n                            \"id\": \"test\", // 唯一标识，母页面中可以通过这个id调用api获取到原生子窗体  \r\n                            \"path\": \"pages/video/subNVue/cover\", // video母页面下原生子窗体页面路径  \r\n                            // \"type\": \"popup\",  //这里不需要\r\n                            \"style\": {  \r\n                                \"position\": \"absolute\",  \r\n                                // \"dock\":\"right\",\r\n                                \"width\": \"750rpx\",  \r\n                                \"height\": \"150upx\", // 需要设置合适的高度，否则可能出现无法点击原生子窗体下面的内容 \r\n                                \"background\":\"transparent\" // 设置为透明，以便能看到原生子窗体下面的内容 ，如果有背景颜色，则全屏可见\r\n                            }  \r\n                 }]\r\n            }\r\n        }\r\n    ]\r\n}pages.json文件中配置好原生子窗体后，不需要向vue组件一样引入到母页中，直接就会出现在母页面上，具体位置根据subNVues中的配置而定。六、优化自定义导航栏下拉刷新功能前面说过，使用自定义导航栏需要隐藏掉默认导航栏和原生导航栏，但是会存在一个问题，就是页面下拉刷新会跟着上移到了最顶部，导致页面下拉刷新位置不正确，之前的方法是使用<scroll-view>方法进行模拟， 但是官方并不推荐该方法 ，我们可以通过原生子窗口实现，其实现方法非常简单，就是用原生子窗口占据原生导航栏的位置，其中关键的一步就是，在配置原生子窗体的时候， 需要将其type设置为navigationBar类型 ，该原生子窗体就会站住原生导航栏的位置，并且下拉刷新图标不会向上移，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/nav/nav\",\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"navigationBarBackgroundColor\":\"#007AFF\",\r\n            \"enablePullDownRefresh\": true,\r\n            \"app-plus\": {\r\n                \"titleNView\": false,\r\n                \"subNVues\": [\r\n                    {\r\n                        \"id\":\"nav\",\r\n                        \"path\":\"pages/nav/subNvue/nav\",\r\n                        \"type\":\"navigationBar\" // 设置为navigationBar类型才能让原生子窗体站住原生导航栏的位置\r\n                    }\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    ]\r\n}pages/nav/subNvue/nav.nvue<template>\r\n    <div class=\"nav\">\r\n        <div class=\"status-bar\"></div>\r\n        <div class=\"nav-title\">\r\n            <div>我是导航栏</div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        \r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n.nav { /*.nvue页面中的所有元素都是flex布局,不需要进行显示设定*/\r\n    flex: 1; /*占满整个导航栏高度,当该原生子窗体页面被设置为navigationBar类型后,会自动给予该页面一个导航高度,占满即可*/\r\n    background-color: #007AFF;\r\n}\r\n.status-bar { /*状态栏占位区,下面导航标题栏已经设置了44px高度，让状态栏占满剩余高度*/\r\n    flex: 1; \r\n}\r\n.nav-title {\r\n    flex: 0;\r\n    height: 44px; /*导航栏固定高度为44px*/\r\n    background-color: #007AFF;\r\n    justify-content: center;\r\n    align-items: center;/*导航栏标题区垂直居中显示*/\r\n}\r\n</style>七、实现抽屉效果所谓抽屉效果就是，就是页面上触发某种事件后，页面上方有一个页面从屏幕的一侧开始滑出覆盖到原来页面的上方，然后点击空白处，该页面又可以收回去的效果。要实现这种效果，我们也是需要利用原生子窗体，将抽屉页面做成一个原生子窗体覆盖在页面上方，其中关键的一步，就是 需要将其type设置为popup类型 ， 设置为popup类型之后 ， 该页面默认不会出现在母页面上 ，需要通过调用api才能让该抽屉页面显示出来。如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/nav/nav\",\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"navigationBarBackgroundColor\":\"#007AFF\",\r\n            \"enablePullDownRefresh\": true,\r\n            \"app-plus\": {\r\n                \"titleNView\": false,\r\n                \"subNVues\": [\r\n                    {\r\n                        \"id\":\"drawer\",\r\n                        \"path\":\"pages/nav/subNvue/drawer\",\r\n                        \"type\":\"popup\",\r\n                        \"style\": {\r\n                            \"width\":\"50%\" // 只显示整个屏幕宽度的50%,高度默认为屏幕100%\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    ]\r\n}pages/nav/subNvue/nav.nvue 母页通过api控制原生子窗体的显示和隐藏<template>\r\n    <view>\r\n        母页面\r\n        <button @click=\"showDrawer\">显示抽屉</button>\r\n    </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                \r\n            }\r\n        },\r\n        methods: {\r\n            showDrawer() {\r\n                uni.getSubNVueById('drawer').show(\"slide-in-left\", 200); // 从屏幕左侧向右边滑入，耗时200ms\r\n            }\r\n        }\r\n    }\r\n</script>同样的方式也可以实现页面中间显示弹出框效果，只需要改变原生子窗体的位置即可，即将其定位到正中间，如:{\r\n    \"id\":\"drawer\",\r\n    \"path\":\"pages/nav/subNvue/drawer\",\r\n    \"type\":\"popup\",\r\n    \"style\": {\r\n        \"margin\":\"auto\", // 居中显示\r\n        \"height\":\"50%\",\r\n        \"width\":\"80%\"\r\n    }\r\n}"}
{"title": "小程序下找地点、查路线、搜地铁，用这3个插件就够了！ ", "author": "Rolan", "pub_time": "2019-10-14 00:19", "content": "自从2017年微信上线小程序以来，小程序已经迅速成长为一个巨大的生态，吸引各行各业的开发者或服务商参与其中。而由于小程序与线下场景的结合日益紧密，地图类功能已经成为越来越多小程序的“标配”，背后也大部分直接或间接的依赖腾讯位置服务提供的地图能力：如出行利器小程序「摩拜单车」，吃喝玩乐的小程序「美团外卖」，圈粉无数的小程序「玩转故宫」，校园导览类小程序「清华校园导览」，领略大美云南的「游云南」等等。一般来说，如果只是开发一些简单的地图功能，小程序开发者还可以轻松应对；但随着地图应用场景的增多，开发者就可能需要用到比如路线规划、地图选点等比较高级的地图能力，这就需要开发者掌握比较复杂的地图接口，开发难度提升，成本较高。为了帮助开发者“减负”，腾讯位置服务推出了「路线规划」「地图选点」「地铁图」三款小程序插件，帮助开发者5分钟内快速搭建属于你的地图能力！​路线规划插件路线规划插件提供路线规划等功能，根据起终点，多种出行方式智能规划最佳出行路线及详情。开发者可以将路线规划插件嵌入到自建小程序的页面里，实现路线规划功能。1、大数据加持，智能推荐多种出行方案给出用户合理路线规划是最基本功能，而能否通过大数据及实时路况智能呈现更合适的方案，甚至比用户多想一步超出其预期，才是提升产品体验、提高用户粘度的关键。目前路线规划插件可以为用户提供驾车、公交、步行三种出行方式，其中驾车出行方式基于全面的路网信息，结合实时路况，为用户智能提供多种出行方案；公交出行方式也提供了多种公交换乘方案，用户可以根据偏好选择最佳方案。​2、海量公交运营数据，贴心提醒用户合适路线公共交通是出行的主要方式之一，城市里丰富的公共交通资源让我们从A点到B点有太多的选择。路线规划插件的公交方案不仅可以提供多种出行偏好如少步行、时间短、换乘少等供用户选择，而且我们还整合了大量的公交实时运营数据，包括交通管制、运营时间、线路临时更改等等，可以准确告知用户在某个出行的时间内是否有合适的车辆，避免错过公交的尴尬。​地图选点插件地图选点插件可以让用户快速、准确地选择并确认自己的当前位置，并将相关位置信息回传给开发者。同时我们还提供位置检索、关键词分类、POI主子点等辅助功能。1、分类筛选，地点信息精准呈现选点是地图应用中使用频率最高的功能之一。购物时标注收货地址、游玩时寻找附近的餐馆、甚至找银行找医院等等，生活中的方方面面，都需要地图能帮助我们找到一个点或一类点。而我们熟悉的微信发送位置时，经常碰见尴尬的场景是地址列表提供的位置太多，掺杂了我们不需要的地点信息。如何提高用户在地图上选点的体验？告别无效地点信息，地点信息的快速精准呈现才是硬道理！选点插件提供了美食、购物、生活购物、娱乐休闲等多达19个一级分类、452个分类筛选！（详情请了解­­：腾讯地图POI分类关键词）开发者可以根据小程序的使用场景，对地点分类进行设置，同时提供分类筛选，引导用户快速精准选择地点信息。例如，在餐饮类的小程序当中，开发者可以在搜索结果中只展示川菜、湘菜、鲁菜、粤菜等餐馆的分类，而其他类型地点数据则不予展示；同时，用户也可以通过分类筛选快速找到自己想要的地点。​2、地点信息结构化呈现，“主子”关系一目了然想象一下如下场景：“喂喂，我们哪里碰面？”“西直门地铁站”“哪个口？”“我……”对于一个大型的地点信息，往往会包含若干个“子点”。例如上面提到的西直门地铁站，下面会包含若干个出口，相对于西直门地铁站这个“主点”来说，他们就是所谓的“子点”。​选点插件在搜索时提供了目标地点和其相关联的地点信息，用户只需要搜索地点部分内容如“西直门”时，在列表中会展示其相关联的地点信息 “C口（东南口）”“D口（西南口）”等，通过这种结构化呈现的方式，帮助用户快速找到附着在“主点”下的“子点”。地铁图插件当今地铁线路图俨然成为一座城市的符号，如果能在小程序中快速浏览地铁图、查找地铁路线，无疑可以给用户带来极大的便利。地铁图插件可以展示静态的城市地铁线路以及站点信息，同时还提供地铁线路检索、查找最近定位站点信息、站点详情查看等功能。开发者可以将城市地铁图嵌入到自建小程序的页面里，轻松实现地铁图功能。​如何接入​腾讯位置服务提供的小程序插件致力于降低小程序开发者开发地图功能的成本，并且打造完善的小程序地图闭环体验。目前我们已经提供了路线规划、地图选点、地铁图插件产品，其他插件也在陆续的开发中。我们将不断完善扩展插件能力，优化插件使用体验，满足开发者更多的需求，覆盖不同场景下的地图使用需求。现在就来体验「地铁图」「路线规划」「地图选点」微信小程序插件，感受简单快捷的地图服务，只需5分钟，搭建你的小程序地图！同时也欢迎开发者给与我们更多的反馈（QQ群：659847796），如果有好的建议和需求，一定要告诉我们，让我们为开发者提供更多更好的地图插件！"}
{"title": "借助小程序·云开发制作校园导览小程序丨实战 ", "author": "Rolan", "pub_time": "2019-10-14 00:21", "content": "背景当你刚上大学的时候，要想不迷失校园，除了依靠不怎么可靠的路边标识外，总会收到那么一张卡通绘制的校园地图：这种静态图片可以让我们快速地了解到所需的地理位置信息，但使用和思考过后，会发现以下问题：地理位置信息粒度高，而同一个地点通常具有多个服务功能和别名。地理位置信息变更导致地图信息过时。一旦服务网点迁移或更名，需要重绘地图，带来一定的延迟和信息滞后。入口较深。存储在手机上的地图并不是那么好找，尤其是随着时间的推移。无法准确的定位当前所处位置，需要寻找参照物，这是静态地图致命的缺点。缺乏更为详细的地点介绍，只能在有限的画面里堆积内容。为此，我设计了一款校园导览应用，用当下流行的微信小程序结合云开发能力，低成本高效能地解决了以上问题。此外，我还根据对市面上的同类应用进行设计上的研究，在界面和交互设计上做功夫。下面我会进行简短的介绍。南苑导览南苑导览是一款由学生独立开发的以地图为载体，提供 中山大学南方学院 （南苑）具体地点的位置信息、导航、校园历史及文化介绍的小程序。旨在解决校园导航标识不到位、地图形式低效单一、信息设计不够好等问题，为来南苑新人和游客提供更加完美的出行体验。<div align=center>仅需修改地图配置文件，即可适配任意场景（校园、景区）的小程序个性化地图定制。技术栈：原生小程序 + TypeScript + gulp + vantUI + 云开发能力2019 微信小程序高校大赛 · 华南赛区二等奖</div>南苑导览 · 开发config 配置├─ src\r\n├─── config\r\n├───── index.ts // 入口\r\n├───── cloud.ts // 云开发相关配置\r\n├───── info.ts // 应用介绍信息\r\n├───── markerStyle.ts // 地图marker样式\r\n├───── panorama.ts // 第三方全景地图配置（个人类型无webview权限，默认关闭）\r\n└───── secret.ts // 腾讯地图key等敏感信息（可选）使用云数据库// markers表 数据格式\r\n{\r\n  _id: \"5ce8fe1c29c7a8581bc1e989\",  // id，云数据库录入upsert更新用\r\n  type: \"生活服务\",   // 场景名称\r\n  icon: \"shfw\",     // marker默认图标，为场景名称拼音缩写\r\n  scale: 15.0,   // 场景在地图上的缩放值，可选。已废弃，用includePoints代替\r\n  position: 0, // 指定在各个场景中的排列顺序\r\n  data: [   // 该场景下的地点markers\r\n    {\r\n      name: \"孙中山铜像\",   // 地点名称\r\n      short_name: \"铜像\", // 名称缩写\r\n      desc: \"中山铜像...\", // 描述信息\r\n      logo: \"tx\",   // 地点logo，缩写拼音, 如作各院系logo展示\r\n      icon: \"tx@2\",   // 自定义marker图标，“@”后数字为图标相较于默认图标的缩放值\r\n      images: 3,  // 图片数量，作云存储拼接路径用（cloud://cloudRoot/1教/n.jpg）\r\n      panorama: 0,  // 全景场景id\r\n      latitude: \"23.635875\",  // 经度\r\n      longitude: \"113.678965\",  // 纬度\r\n      contact: { phone: \"020-123456\", address: \"出门左转\" }   // 联系方式\r\n    }\r\n  ]\r\n}使用 excel 进行数据维护，通过 python pandas 进行数据清洗，使用 jsonlines 库输出符合云数据库的 JSON Lines 格式文件，以 upsert 形式导入数据库。数据更新流程如下：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Kzq570X-1570761839095)( https://656e-enanyuan-6db383-... ]加载并清洗数据使用 request 或云数据库进行异步数据请求时。由于 app.js 中的 onLaunch 和首页 index 的 onLoad 的执行顺序不是固定的，所以如果首页有基于 app.js 请求的数据时要注意生命周期的问题。// index\r\nasync loadMarkers() {\r\n  let markers;\r\n  if (app.globalData.config.debug) {\r\n    // 本地\r\n    markers = mockMarkers;\r\n  } else {\r\n    // 云\r\n    await wx.cloud\r\n      .callFunction({\r\n        name: \"loadMarkers\"\r\n      })\r\n      .then((res: any) => {\r\n        markers = res.result.data;\r\n      });\r\n  }\r\n  app.globalData.markers = markers;\r\n}\r\n\r\nclearMarkers(markers: any[]) {\r\n  let num = 0;  // 每个marker都要有一个id\r\n  for (const i of markers) {\r\n    for (const j of i.data) {\r\n      j.id = num;\r\n      num += 1;\r\n      j.iconPath = `/assets/images/markers/${j.icon ? j.icon : i.icon}.png`;\r\n\r\n      ...\r\n\r\n      // 自定义气泡样式\r\n      j.callout = Object.assign(\r\n        { content: j.short_name ? j.short_name : j.name },\r\n        app.globalData.config.markerStyle.calloutStyle\r\n      );\r\n    }\r\n  }\r\n  return markers;\r\n}巧用 MapContext你不需要去手动地为每个场景设置 scale，用 includePoints 即可让地图视野自动覆盖到当前所有 POI。你也不需要去手动地去获取权限设置用户位置，用 moveToLocation 即可轻松定位。// index\r\nonReady() {\r\n  this.setData!({\r\n    mapContext: wx.createMapContext(\"map\")\r\n  });\r\n}\r\n\r\nincludePoints(padding: number) {\r\n  this.data.mapContext.includePoints({\r\n    padding: [padding, padding, padding, padding],\r\n    points: this.data.markers\r\n  });\r\n}\r\n\r\nlocate() {\r\n  this.data.mapContext.moveToLocation();\r\n}使用云存储管理图片添加新图片时，直接修改 images 字段即可，文件夹目录为地点名称。<!-- 地点详情页 轮播图 -->\r\n<swiper\r\n  indicator-dots=\"{{imgUrls.length > 1}}\"\r\n  autoplay=\"{{true}}\"\r\n  interval=\"3000\"\r\n  duration=\"1000\"\r\n>\r\n  <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">\r\n    <swiper-item>\r\n      <image\r\n        src=\"{{item}}\"\r\n        class=\"slide\"\r\n        data-id=\"{{index}}\"\r\n        bindtap=\"previewImage\"\r\n      />\r\n    </swiper-item>\r\n  </block>\r\n</swiper>for (let i = 0; i < marker.images; i++) {\r\n  imgUrls.push(\r\n    this.data.cloudRoot +\r\n      \"images/\" +\r\n      (marker.short_name || marker.name) +\r\n      \"/\" +\r\n      i +\r\n      \".jpg\"\r\n  );\r\n}南苑导览 · 设计如果你在微信上搜索「导览」二字，看到的小程序大多都是一个模板，页面层级深，界面拥挤，列表式的信息展示并不符合我们日常使用地图 APP 的经验。为此，我做出了多项改良：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j76bV81T-1570761839095)( https://656e-enanyuan-6db383-... ]更好的视野 - 自定义导航栏与侧边栏因为只有特定的页面需要使用自定义导航栏，所以只需要设置页面级的 config：\"navigationStyle\": \"custom\"接下来获取胶囊按钮位置信息：bounding: wx.getMenuButtonBoundingClientRect();[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XoDA3u2I-1570761839096)( https://656e-enanyuan-6db383-... ]动态地设置样式：<!-- SIDE MENU -->\r\n<view\r\n  class=\"sidebar\"\r\n  hidden=\"{{toggleRoutes}}\"\r\n  style=\"top:{{bounding.height + bounding.top + 10}}px\"\r\n>\r\n  ...\r\n</view>FAB 与侧边栏设计把最主要的定位、搜索和路线推荐功能在视觉上成为整体，通过点击 FAB 弹出菜单选项。侧边栏的地点场景菜单设计为下拉滚动，注意使用半遮设计来提醒用户滚动。同时，为了让界面更加精简，侧边菜单会在点击 FAB（Float Action Button）和母按钮时 toggle 显示与隐藏。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SP3GrjOr-1570761839096)( https://656e-enanyuan-6db383-... ]用点击代替滚动 - scroll-into-view在路线面板和搜索页中，使用到了 scroll-view 组件，利用其 scroll-into-view 特性，实现点击代替滚动的操作，同时也能起到提醒后置选项的作用。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o18t46ea-1570761839097)( https://656e-enanyuan-6db383-... ]windowWidth: wx.getSystemInfoSync().screenWidth;<scroll-view class=\"route\" scroll-x scroll-into-view=\"{{focusPointId}}\">\r\n  <view\r\n    class=\"points\"\r\n    style=\"width:{{routes[routeIndex].count * 140 < windowWidth ? windowWidth : routes[routeIndex].count * 140}}rpx;\"\r\n  >\r\n    ...\r\n  </view>\r\n</scroll-view>更好的视角 - 全景功能结合 web-view 和全景服务平台，可以为一款地图导览应用增色不少。总结云开发让小程序开发者无需搭建服务器，使用平台提供的 API 即可快速地进行业务开发、上线和迭代，免费的基础版完全可以满足中小应用的需求。「南苑导览」借助腾讯云开发能力，上线以来，帮助到了许许多多的新生和来客，实现了产品价值。最后，期望官方早日开放自定义地图底图能力，让开发者能够个性化地图，探索出更多的应用场景！源码地址https://github.com/TencentCloudBase/Good-practice-tutorial-recommended"}
{"title": "在微信小程序里面不使用checkbox怎么实现view的多选 ", "author": "Rolan", "pub_time": "2019-9-24 00:27", "content": "wxml文件<block wx:for=\"{{itemList}}\" wx:key=\"id\">  <view class='item_container' bindtap='itemSelected' data-index='{{index}}'>     <image class='select_icon' src=\"{{item.isSelected?'/image/selected.png':'/image/unselected.png'}}\"></image>     <text class='text'>{{item.name}}</text>  </view></block>wxss文件.item_container {  display: flex;  flex-direction: row;  align-items: center;  padding: 20rpx;} .select_icon {  width: 40rpx;  height: 40rpx;} .text {  margin-left: 30rpx;}js文件data: {    itemList: [      { id: 1, name: 'C语言', isSelected: false, },      { id: 2, name: 'Java', isSelected: false, },      { id: 3, name: 'C++', isSelected: false, },    ]  }, itemSelected: function (e) {    var index = e.currentTarget.dataset.index;    var item = this.data.itemList[index];    item.isSelected = !item.isSelected;    this.setData({      itemList: this.data.itemList,    });  }效果如图"}
{"title": "【小程序】小程序优化-代码篇 ", "author": "Rolan", "pub_time": "2019-9-29 00:09", "content": "不知道大家有没有这种体会，刚到公司时，领导要你维护之前别人写的代码，你看着别人写的代码陷入了深深的思考：“这谁写的代码，这么残忍”俗话说“不怕自己写代码，就怕改别人的代码”，一言不和就改到你吐血，所以为了别人好，也为了自己好，代码规范，从我做起。项目目录结构在开发之前，首先要明确你要做什么，不要一上来就是干，咱们先把项目结构搭好。一般来说，开发工具初始化的项目基本可以满足需求，如果你的项目比较复杂又有一定的结构的话就要考虑分好目录结构了，我的做法如下图：component文件夹是放自定义组件的pages放页面public放公共资源如样式表和公共图标units放各种公共api文件和封装的一些js文件config.js是配置文件这么分已经足以满足我的需求，你可以根据自己的项目灵活拆分。配置文件我的项目中有个config.js，这个文件是用来配置项目中要用到的一些接口和其它私有字段，我们知道在开发时通常会有测试环境和正式环境，而测试环境跟正式环境的域名可能会不一样，如果不做好配置的话直接写死接口那等到上线的时候一个个改会非常麻烦，所以做好配置是必需的，文件大致如下：首先是定义域名，然后在config对象里定义接口名称，getAPI(key)是获取接口方法，最后通过module暴露出去就可以了.引用的时候只要在页面引入 import domain from '../../config'; ，然后wx.request的时候url的获取方式是 domain.getAPI('')代码健壮性、容错性例子代码的健壮性、容错性也是我们应该要考虑的一点，移动端的项目不像pc端的网络那么稳定，很多时候网络一不稳定就决定我们的项目是否能正常运行，而一个好的项目就一定要有良好的容错性，就是说在网络异常或其它因素导致我们的项目不能运行时程序要有一个友好的反馈，下面是一个网络请求的例子：相信多数人请求的方式是这样，包括我以前刚接触小程序的时候也是这样写，这样写不是说不好，而是不太严谨，如果能够正常获取数据那还好，但是一旦请求出现错误那程序可以到此就没法运行下去了，有些比较好的会加上faill失败回调，但也只是请求失败时的判断，在请求成功到获取数据的这段流程内其实是还有一些需要我们判断的，一般我的做法是这样：在请求成功后小程序会进行如下判断：判断是否返回200，是则进行一下步操作，否则抛出错误判断数据结构是否完整，是则进行一下步操作，否则抛出错误然后就可以在页面根据情况进行相应的操作了。定制错误提示码可以看到上面的截图的错误打印后面会带一个gde0或gde1的英文代码，这个代码是干嘛用的呢，其实是用来报障的，当我们的小程序上线后可能会遇到一些用户发来的报障，一般是通过截图发给我们，之前没有做错误提示码的时候可能只是根据一句错误提示来定位错误，但是很多时候误提示语都是一样的，我们根本不知道是哪里错了，这样一来就不能很快的定位的错误，所以加上这样一个提示码，到时用户一发截图来，我们只要根据这个错误码就能很快的定位错误并解决了，错误提示码建议命名如下：不宜过长，3个字母左右唯一性意义明确像上面gde表示获取草稿失败，后面加上数字表示是哪一步出错。模块化我们组内的大神说过， 模块化的意义在义分治，不在于复用 。 之前我以为模块化只是为了可以复用，其实不然，无论模块多么小也是可以模块化，哪怕只是一个简单的样式也一样，并是不为了复用，而是管理起来方便。 很多同学经常将一些公共的样式事js放在app.wxss和app.js里以便调用，这样做其实有一个坏处，就是维护性比较差，如果是比较小的项目还好，项目一大问题就来了。而且项目是会迭代的，不可能总是一个人开发，可能后面会交接给其他人开发，所以会造成的问题就是：app.wxss和app.js里的内容只会越来越多，因为别人不确定哪些是没用的也不敢删，只能往里加东西，造成文件臃肿，不利于维护。app.wxss和app.js对于每个页面都有效，可读性方面比较差。所以模块化的意义就出来了，将公共的部分进行模块化统一管理，也便于维护。样式模块化公共样式根据上面的目录结构我是放在public里的css里，每个文件命名好说明是哪个部分的模块化，比如下面这个就表示一个按钮的模块化前面说过模块化不在于大小，就算只是一个简单的样式也可以进行模块化，只要在用到的地方import一下就行了，就知道哪里有用到，哪里没有用到，清晰明了。js模块化js模块化这里分为两个部分的模块化，一部分是公共js的模块化，另一部分是页面js的模块化即业务与数据的拆分。公共js模块化比较常用的公共js有微信登录，弹窗，请求等，一般我是放在units文件夹里，这里经微信弹窗api为例：如图是在小程序中经常会用到的弹窗提示，这里进行封装，定义变量，只要在页面中引入就能直接调用了，不用每次都写一大串。比如在请求的时候是这样用的toast()就是封装的弹窗api，这样看起来是不是清爽多了！业务与数据模块化业务与数据模块化就是指业务和数据分开，互不影响，业务只负责业务，数据只负责数据，可以看到页面会比普通的页面多了一个api.js这个文件主要就是用来获取数据的，而index.js主要用来处理数据，这样分工明确，相比以往获取数据和处理数据都在一个页面要好很多，而且我这里获取数据是返回一个promise对象的，也方便处理一些异步操作。组件化组件化相信大家都不陌生了，自从小程序支持自定义组件，可以说是大大地提高了开发效率，我们可以将一些公共的部分进行组件化，这部分就不详细介绍，大家可以去看文档。组件化对于我们的项目来说有很大的好处，而且组件化的可移植性强，从一个项目复用到另一个项目基本不需要做什么改动。"}
